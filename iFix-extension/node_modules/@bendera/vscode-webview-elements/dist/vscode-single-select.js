var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { chevronDownIcon } from './includes/vscode-select/template-elements';
import { VscodeSelectBase } from './includes/vscode-select/vscode-select-base';
/**
 * ## Types
 *
 * ```typescript
 *interface Option {
 *  label: string;
 *  value: string;
 *  description: string;
 *  selected: boolean;
 *  disabled: boolean;
 *}
 * ```
 * @attr name - Name which is used as a variable name in the data of the form-container.
 */
let VscodeSingleSelect = class VscodeSingleSelect extends VscodeSelectBase {
    constructor() {
        super();
        this.role = 'listbox';
        this._labelText = '';
        this._multiple = false;
    }
    set selectedIndex(val) {
        this._selectedIndex = val;
        this._value = this._options[this._selectedIndex]
            ? this._options[this._selectedIndex].value
            : '';
        this._labelText = this._options[this._selectedIndex]
            ? this._options[this._selectedIndex].label
            : '';
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set value(val) {
        if (this._options[this._selectedIndex]) {
            this._options[this._selectedIndex].selected = false;
        }
        this._selectedIndex = this._options.findIndex((op) => op.value === val);
        if (this._selectedIndex > -1) {
            this._options[this._selectedIndex].selected = true;
            this._labelText = this._options[this._selectedIndex].label;
            this._value = val;
        }
        else {
            this._labelText = '';
            this._value = '';
        }
    }
    get value() {
        var _a;
        if (this._options[this._selectedIndex]) {
            return (_a = this._options[this._selectedIndex]) === null || _a === void 0 ? void 0 : _a.value;
        }
        return '';
    }
    updateInputValue() {
        if (!this.combobox) {
            return;
        }
        const input = this.renderRoot.querySelector('.combobox-input');
        if (input) {
            input.value = this._options[this._selectedIndex]
                ? this._options[this._selectedIndex].label
                : '';
        }
    }
    _onSlotChange() {
        super._onSlotChange();
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex].label;
        }
    }
    _onArrowUpKeyDown() {
        super._onArrowUpKeyDown();
        if (this._showDropdown || this._selectedIndex <= 0) {
            return;
        }
        this._filterPattern = '';
        this._selectedIndex -= 1;
        this._activeIndex = this._selectedIndex;
        this._labelText = this._options[this._selectedIndex].label;
        this._value = this._options[this._selectedIndex].value;
        this._dispatchChangeEvent();
    }
    _onArrowDownKeyDown() {
        super._onArrowDownKeyDown();
        if (this._showDropdown || this._selectedIndex >= this._options.length) {
            return;
        }
        this._filterPattern = '';
        this._selectedIndex += 1;
        this._activeIndex = this._selectedIndex;
        this._labelText = this._options[this._selectedIndex].label;
        this._value = this._options[this._selectedIndex].value;
        this._dispatchChangeEvent();
    }
    _onEnterKeyDown() {
        super._onEnterKeyDown();
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex].label;
        }
        this.updateInputValue();
    }
    _onOptionClick(ev) {
        const composedPath = ev.composedPath();
        const optEl = composedPath.find((et) => { var _a; return (_a = et) === null || _a === void 0 ? void 0 : _a.matches('li.option'); });
        if (!optEl || optEl.matches('.disabled')) {
            return;
        }
        this._selectedIndex = Number(optEl.dataset.index);
        this._value = this._options[this._selectedIndex].value;
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex].label;
        }
        this._toggleDropdown(false);
        this._dispatchChangeEvent();
    }
    _renderLabel() {
        const labelContent = this._labelText || html `<span class="empty-label-placeholder"></span>`;
        return html `<span class="text">${labelContent}</span>`;
    }
    _renderSelectFace() {
        return html `
      <div class="select-face" @click="${this._onFaceClick}">
        ${this._renderLabel()} ${chevronDownIcon}
      </div>
    `;
    }
    _renderComboboxFace() {
        const inputVal = this._selectedIndex > -1 ? this._options[this._selectedIndex].label : '';
        return html `
      <div class="combobox-face">
        <input
          class="combobox-input"
          spellcheck="false"
          type="text"
          .value="${inputVal}"
          @focus="${this._onComboboxInputFocus}"
          @input="${this._onComboboxInputInput}"
        />
        <button
          class="combobox-button"
          type="button"
          @click="${this._onComboboxButtonClick}"
          @keydown="${this._onComboboxButtonKeyDown}"
        >
          ${chevronDownIcon}
        </button>
      </div>
    `;
    }
    _renderOptions() {
        const list = this.combobox ? this._filteredOptions : this._options;
        const options = list.map((op, index) => {
            const classes = classMap({
                option: true,
                active: index === this._activeIndex && !op.disabled,
                disabled: op.disabled,
            });
            return html `
        <li
          class="${classes}"
          data-index="${op.index}"
          data-filtered-index="${index}"
        >
          ${op.label}
        </li>
      `;
        });
        return html `
      <ul
        class="options"
        @mouseover="${this._onOptionMouseOver}"
        @click="${this._onOptionClick}"
      >
        ${options}
      </ul>
    `;
    }
};
__decorate([
    property({ type: String, attribute: true, reflect: true })
], VscodeSingleSelect.prototype, "role", void 0);
__decorate([
    property({ type: Number })
], VscodeSingleSelect.prototype, "selectedIndex", null);
__decorate([
    property({ type: String })
], VscodeSingleSelect.prototype, "value", null);
__decorate([
    state()
], VscodeSingleSelect.prototype, "_labelText", void 0);
VscodeSingleSelect = __decorate([
    customElement('vscode-single-select')
], VscodeSingleSelect);
export { VscodeSingleSelect };
//# sourceMappingURL=vscode-single-select.js.map