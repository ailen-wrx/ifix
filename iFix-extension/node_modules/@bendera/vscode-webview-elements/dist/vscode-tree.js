var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { css, html, nothing } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
import { VscElement } from './includes/VscElement';
import './vscode-icon';
var KeyName;
(function (KeyName) {
    KeyName["ARROW_DOWN"] = "ArrowDown";
    KeyName["ARROW_UP"] = "ArrowUp";
    KeyName["ENTER"] = "Enter";
    KeyName["ESCAPE"] = "Escape";
    KeyName["SPACE"] = " ";
})(KeyName || (KeyName = {}));
var ItemType;
(function (ItemType) {
    ItemType["BRANCH"] = "branch";
    ItemType["LEAF"] = "leaf";
})(ItemType || (ItemType = {}));
const ARROW_OUTER_WIDTH = 18;
const mapData = (tree, prevPath = []) => {
    const nextTree = [];
    tree.forEach((val, index) => {
        const { label, subItems, open, selected, focused, icons, value } = val;
        const path = [...prevPath, index];
        const nextItem = {
            label,
            path,
            open: !!open,
            selected: !!selected,
            focused: !!focused,
            icons: { ...icons },
            value,
        };
        if (subItems) {
            nextItem.subItems = mapData(subItems, path);
        }
        nextTree.push(nextItem);
    });
    return nextTree;
};
/**
 * ## Type definitions
 *
 * ```typescript
 * type ItemType = 'branch' | 'leaf';
 *
 * interface TreeItemIconConfig {
 *   branch?: string;
 *   open?: string;
 *   leaf?: string;
 * }
 *
 * interface TreeItem {
 *   label: string;
 *   subItems?: TreeItem[];
 *   open?: boolean;
 *   selected?: boolean;
 *   focused?: boolean;
 *   icons?: TreeItemIconConfig;
 *
 *   // If it's not defined the value will be equal to the label
 *   value?: string;
 *
 *   // Item path in the tree. For example [0,0,1] means:
 *   // tree[0].subItems[0].subItems[1]
 *   path?: number[];
 * }
 *
 * interface SelectEventDetail {
 *   icons: TreeItemIconConfig | undefined;
 *   itemType: ItemType;
 *   label: string;
 *   open: boolean;
 *   value: string;
 *   path: string; // ex.: 0/0/1
 * }
 * ```
 */
let VscodeTree = class VscodeTree extends VscElement {
    constructor() {
        super(...arguments);
        this.indent = 8;
        this.arrows = false;
        this.multiline = false;
        this.tabindex = 0;
        this._data = [];
        this._selectedItem = null;
        this._focusedItem = null;
        this.onComponentKeyDownBound = this.onComponentKeyDown.bind(this);
    }
    set data(val) {
        const oldVal = this._data;
        this._data = mapData(val);
        this.requestUpdate('data', oldVal);
    }
    get data() {
        return this._data;
    }
    getItemByPath(path) {
        let current = this._data;
        let item = null;
        path.forEach((el, i) => {
            if (i === path.length - 1) {
                item = current[el];
            }
            else {
                current = current[el].subItems;
            }
        });
        return item;
    }
    getItemType(item) {
        if (item.subItems &&
            Array.isArray(item.subItems) &&
            item.subItems.length > 0) {
            return ItemType.BRANCH;
        }
        return ItemType.LEAF;
    }
    getIconName(element) {
        if (!element.icons) {
            return undefined;
        }
        const { icons } = element;
        const itemType = this.getItemType(element);
        const isOpen = element.open || false;
        if (itemType === ItemType.BRANCH && isOpen) {
            return icons.open || undefined;
        }
        else if (itemType === ItemType.BRANCH && !isOpen) {
            return icons.branch || undefined;
        }
        else if (itemType === ItemType.LEAF) {
            return icons.leaf || undefined;
        }
        else {
            return undefined;
        }
    }
    renderTreeItem({ indentLevel, label, path, iconName, open = false, itemType, selected = false, focused = false, subItems, }) {
        const arrowIconName = open ? 'chevron-down' : 'chevron-right';
        const contentsClasses = ['contents'];
        const liClasses = open ? ['open'] : [];
        const indentSize = indentLevel * this.indent;
        const padLeft = this.arrows && itemType === ItemType.LEAF
            ? ARROW_OUTER_WIDTH + indentSize
            : indentSize;
        const arrowMarkup = this.arrows && itemType === ItemType.BRANCH
            ? html `<vscode-icon
            name="${arrowIconName}"
            class="icon-arrow"
          ></vscode-icon>`
            : nothing;
        const iconMarkup = iconName
            ? html `<vscode-icon name="${iconName}" class="label-icon"></vscode-icon>`
            : nothing;
        const subTreeMarkup = open && itemType === ItemType.BRANCH
            ? html `<ul>
            ${this.renderTree(subItems, path)}
          </ul>`
            : nothing;
        const labelMarkup = html `<span class="label">${label}</span>`;
        liClasses.push(itemType === ItemType.LEAF ? 'leaf' : 'branch');
        if (selected) {
            contentsClasses.push('selected');
        }
        if (focused) {
            contentsClasses.push('focused');
        }
        return html `
      <li data-path="${path.join('/')}" class="${liClasses.join(' ')}">
        <span
          class="${contentsClasses.join(' ')}"
          style="${styleMap({ paddingLeft: `${padLeft}px` })}"
        >
          ${arrowMarkup} ${iconMarkup} ${labelMarkup}
        </span>
        ${subTreeMarkup}
      </li>
    `;
    }
    renderTree(tree, oldPath = []) {
        const ret = [];
        if (!tree) {
            return nothing;
        }
        tree.forEach((element, index) => {
            const path = [...oldPath, index];
            const indentLevel = path.length - 1;
            const itemType = this.getItemType(element);
            const iconName = this.getIconName(element);
            const { label, open = false, selected = false, focused = false, subItems = [], } = element;
            if (selected) {
                this._selectedItem = element;
            }
            if (focused) {
                this._focusedItem = element;
            }
            ret.push(this.renderTreeItem({
                indentLevel,
                label,
                path,
                open,
                iconName,
                itemType,
                selected,
                focused,
                subItems,
            }));
        });
        return ret;
    }
    toggleSubTreeOpen(item) {
        if (!item.subItems) {
            return;
        }
        item.open = !item.open;
    }
    selectTreeItem(item) {
        if (this._selectedItem) {
            this._selectedItem.selected = false;
        }
        this._selectedItem = item;
        item.selected = true;
    }
    focusTreeItem(item) {
        if (this._focusedItem) {
            this._focusedItem.focused = false;
        }
        this._focusedItem = item;
        item.focused = true;
    }
    closeSubTreeRecursively(tree) {
        tree.forEach((item) => {
            item.open = false;
            if (item.subItems && item.subItems.length > 0) {
                this.closeSubTreeRecursively(item.subItems);
            }
        });
    }
    emitSelectEvent(item, path) {
        const { icons, label, open, value } = item;
        const detail = {
            icons,
            itemType: this.getItemType(item),
            label,
            open: open || false,
            value: value || label,
            path,
        };
        this.dispatchEvent(new CustomEvent('vsc-select', {
            bubbles: true,
            composed: true,
            detail,
        }));
    }
    _focusItem(item) {
        if (this._focusedItem) {
            this._focusedItem.focused = false;
        }
        this._focusedItem = item;
        this._focusedItem.focused = true;
    }
    _focusPrevItem() {
        var _a;
        if (!this._focusedItem) {
            this._focusItem(this._data[0]);
            return;
        }
        const { path } = this._focusedItem;
        if (path && (path === null || path === void 0 ? void 0 : path.length) > 0) {
            const currentItemIndex = path[path.length - 1];
            const hasParent = path.length > 1;
            if (currentItemIndex > 0) {
                const newPath = [...path];
                newPath[newPath.length - 1] = currentItemIndex - 1;
                const prevSibling = this.getItemByPath(newPath);
                let newFocusedItem = prevSibling;
                if ((prevSibling === null || prevSibling === void 0 ? void 0 : prevSibling.open) && ((_a = prevSibling.subItems) === null || _a === void 0 ? void 0 : _a.length)) {
                    const { subItems } = prevSibling;
                    newFocusedItem = subItems[subItems.length - 1];
                }
                this._focusItem(newFocusedItem);
            }
            else {
                if (hasParent) {
                    const newPath = [...path];
                    newPath.pop();
                    this._focusItem(this.getItemByPath(newPath));
                }
            }
        }
        else {
            this._focusItem(this._data[0]);
        }
    }
    _focusNextItem() {
        if (!this._focusedItem) {
            this._focusItem(this._data[0]);
            return;
        }
        const { path, open } = this._focusedItem;
        if (open &&
            Array.isArray(this._focusedItem.subItems) &&
            this._focusedItem.subItems.length > 0) {
            this._focusItem(this._focusedItem.subItems[0]);
            return;
        }
        const nextPath = [...path];
        nextPath[nextPath.length - 1] += 1;
        let nextFocusedItem = this.getItemByPath(nextPath);
        if (nextFocusedItem) {
            this._focusItem(nextFocusedItem);
        }
        else {
            nextPath.pop();
            if (nextPath.length > 0) {
                nextPath[nextPath.length - 1] += 1;
                nextFocusedItem = this.getItemByPath(nextPath);
                if (nextFocusedItem) {
                    this._focusItem(nextFocusedItem);
                }
            }
        }
    }
    onComponentClick(event) {
        const composedPath = event.composedPath();
        const targetElement = composedPath.find((el) => el.tagName &&
            el.tagName.toUpperCase() === 'LI');
        if (targetElement) {
            const pathStr = targetElement.dataset.path || '';
            const path = pathStr.split('/').map((el) => Number(el));
            const item = this.getItemByPath(path);
            this.toggleSubTreeOpen(item);
            this.selectTreeItem(item);
            this.focusTreeItem(item);
            this.emitSelectEvent(item, pathStr);
            this.requestUpdate();
        }
        else {
            if (this._focusedItem) {
                this._focusedItem.focused = false;
            }
            this._focusedItem = null;
        }
    }
    onComponentKeyDown(ev) {
        const keys = [
            KeyName.ARROW_DOWN,
            KeyName.ARROW_UP,
            KeyName.ENTER,
            KeyName.ESCAPE,
            KeyName.SPACE,
        ];
        if (keys.includes(ev.key)) {
            ev.stopPropagation();
            ev.preventDefault();
        }
        if (ev.key === KeyName.ESCAPE) {
            this._focusedItem = null;
        }
        if (ev.key === KeyName.ARROW_UP) {
            this._focusPrevItem();
        }
        if (ev.key === KeyName.ARROW_DOWN) {
            this._focusNextItem();
        }
        if (ev.key === KeyName.ENTER || ev.key === KeyName.SPACE) {
            if (this._selectedItem) {
                this._selectedItem.selected = false;
            }
            if (this._focusedItem) {
                this._selectedItem = this._focusedItem;
            }
            if (this._selectedItem) {
                this._selectedItem.selected = true;
                this._selectedItem.open = !this._selectedItem.open;
                this.emitSelectEvent(this._selectedItem, this._selectedItem.path.join('/'));
                this.requestUpdate();
            }
        }
    }
    closeAll() {
        this.closeSubTreeRecursively(this.data);
        this.requestUpdate();
    }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener('keydown', this.onComponentKeyDownBound);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('keydown', this.onComponentKeyDownBound);
    }
    static get styles() {
        return [
            super.styles,
            css `
        :host {
          display: block;
          outline: none;
          user-select: none;
        }

        .wrapper {
          height: 100%;
        }

        :host(:focus) .wrapper.focused-none {
          outline: 1px solid var(--vscode-list-focusOutline);
        }

        li {
          list-style: none;
        }

        ul,
        li {
          margin: 0;
          padding: 0;
        }

        .contents {
          align-items: center;
          display: flex;
          font-family: var(--vscode-font-family);
          font-size: var(--vscode-font-size);
          font-weight: var(--vscode-font-weight);
        }

        .multi .contents {
          align-items: flex-start;
        }

        .contents:hover {
          background-color: var(--vscode-list-hoverBackground);
          color: var(--vscode-list-hoverForeground);
          cursor: pointer;
        }

        .contents.selected {
          background-color: var(--vscode-list-inactiveSelectionBackground);
        }

        :host(:focus) .contents.focused {
          background-color: var(--vscode-list-focusBackground);
          outline: 1px solid var(--vscode-list-focusOutline);
          outline-offset: -1px;
        }

        :host(:focus) .contents.selected.focused,
        :host(:focus) .contents.selected {
          background-color: var(--vscode-list-activeSelectionBackground);
          color: var(--vscode-list-activeSelectionForeground);
        }

        .icon-arrow {
          display: block;
          margin: 3px 2px 3px 0;
        }

        .label-icon {
          display: block;
          margin-right: 6px;
        }

        :host(:focus) .contents.selected.focused .label-icon,
        :host(:focus) .contents.selected .label-icon {
          color: var(--vscode-list-activeSelectionForeground);
        }

        .multi .contents .label-icon {
          margin-top: 3px;
        }

        .label {
          display: block;
          line-height: 22px;
        }

        .single .label {
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }
      `,
        ];
    }
    render() {
        const classes = classMap({
            multi: this.multiline,
            single: !this.multiline,
            wrapper: true,
            'focused-none': !this._focusedItem,
            'selection-none': !this._selectedItem,
            'selection-single': this._selectedItem !== null,
        });
        return html `
      <div @click="${this.onComponentClick}" class="${classes}">
        <ul>
          ${this.renderTree(this._data)}
        </ul>
      </div>
    `;
    }
};
__decorate([
    property({ type: Array, reflect: false })
], VscodeTree.prototype, "data", null);
__decorate([
    property({ type: Number })
], VscodeTree.prototype, "indent", void 0);
__decorate([
    property({ type: Boolean })
], VscodeTree.prototype, "arrows", void 0);
__decorate([
    property({ type: Boolean })
], VscodeTree.prototype, "multiline", void 0);
__decorate([
    property({ type: Number, reflect: true })
], VscodeTree.prototype, "tabindex", void 0);
__decorate([
    state()
], VscodeTree.prototype, "_selectedItem", void 0);
__decorate([
    state()
], VscodeTree.prototype, "_focusedItem", void 0);
VscodeTree = __decorate([
    customElement('vscode-tree')
], VscodeTree);
export { VscodeTree };
//# sourceMappingURL=vscode-tree.js.map